ERPNet.sln
│
├── 1. Core
│   ├── ERPNet.Domain          (Entities, Enums, Interfaces base)
│   └── ERPNet.Application     (DTOs, Mappings, Interfaces de Repositorios, Lógica de Negocio)
│
├── 2. Infrastructure
│   └── ERPNet.Database     (EF Core: DbContext, Migrations, Repositorios, Configs)
│
├── 3. Presentation
│   ├── ERPNet.Api             (Controllers, Middlewares, Auth)
│   ├── ERPNet.Web.Mobile      (Razor Pages)
│   └── ERPNet.Web.Blazor      (Blazor Server)
│
├── 4. Shared
│   └── ERPNet.Common          (Result Pattern, Helpers, ApiClient , Constants, DTOs)   
│
└── 5. Tests
    └── ERPNet.Tests


Idea de las tablas y lógica

Usuarios: Credenciales de acceso, contraseña hasheada, ultacceso 
Roles: Define el nivel de permiso (Admin, Operario, Jefe de Planta, Responsable de Mantenimiento, Responsable RRHH).
Menus: columna Plataforma (Mobile/Web), otra con el nombre del menu, otra con el id del menu padre, otra con el campo path, otra con el del icono class, otra con un custom class y otra order
PermisosRolMenu: Tabla intermedia para decir qué Rol puede ver qué Menú y si tiene algun permiso especial en esa opción (como borrar)
RolesUsuarios
Logs
Empleados:Datos personales, pertenecen siempre a una seccion, pueden tener un encargado especifico
Secciones: para que un jefe de sección solo apruebe vacaciones de su gente y no de toda la fábrica.  
Vacaciones: Con un campo Estado (Pendiente, Aprobado, Rechazado) asciado a un empleado en una fecha.
Turnos:puede haber turnos de cualquier día a cualquier hora
Marcajes: Registros de entrada/salida.
IncidenciasMarcaje(Si un día llego tarde a su turno pasado una tolerancia se genera autmaticamente, pendiente validar por RRHH y poner observaciones)
Maquinaria
OrdenesMantenimiento
TiposMantenimiento: Una tabla maestra simple para definir "Correctivo", "Preventivo"


Patrón Consulta() — Filtrado por Alcance en Repositorios
=========================================================
Para repos que necesiten filtrar datos según el Alcance del usuario (Global/Seccion/Propio):

1. Inyectar ICurrentUserProvider en el repositorio
2. Declarar el RecursoCodigo que protege la entidad
3. Método privado Consulta() que aplica el filtro:

    private static readonly RecursoCodigo Recurso = RecursoCodigo.Vacaciones;

    private IQueryable<Vacacion> Consulta()
    {
        var query = context.Vacaciones.AsQueryable();
        var alcance = ctxAccessor.Current?.Permisos
            .FirstOrDefault(p => p.Codigo == Recurso)?.Alcance;

        if (alcance is null) return query;

        return alcance switch
        {
            Alcance.Global  => query,
            Alcance.Seccion => query.Where(v => v.Empleado.SeccionId == ctxAccessor.Current!.SeccionId),
            Alcance.Propio  => query.Where(v => v.EmpleadoId == ctxAccessor.Current!.EmpleadoId),
            _ => query.Where(_ => false)
        };
    }

4. Usar Consulta() en GetAllAsync, GetByIdAsync, SoftDeleteAsync, etc.
5. Métodos internos (auth, seeding) van directo a context.Entidad sin Consulta()
