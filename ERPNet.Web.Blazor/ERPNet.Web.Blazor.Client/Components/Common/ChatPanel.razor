@using System.Text
@using System.Text.Json
@using System.Text.Json.Nodes
@using Microsoft.AspNetCore.Components.Forms
@using ERPNet.Web.Blazor.Client.Mcp

@inject McpToolService Mcp
@inject IHttpClientFactory HttpFactory
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="chat-panel">

    <div class="chat-messages" id="chat-messages">
        @if (_displayMessages.Count == 0)
        {
            <div class="chat-welcome">
                <i class="bi bi-robot display-5 mb-3 opacity-25"></i>
                <p class="fw-semibold mb-1">¿En qué puedo ayudarte?</p>
                <p class="text-muted small mb-0">
                    Puedo consultar y gestionar los datos de la página activa,
                    crear registros y navegar a cualquier ficha.
                </p>
            </div>
        }

        @foreach (var msg in _displayMessages)
        {
            if (msg is MensajeUsuario u)
            {
                <div class="chat-bubble chat-bubble-user">
                    @if (u.ImagenDataUrls?.Count > 0)
                    {
                        <div class="chat-bubble-images">
                            @foreach (var url in u.ImagenDataUrls)
                            {
                                <img src="@url" class="chat-bubble-img" alt="imagen adjunta" />
                            }
                        </div>
                    }
                    @if (!string.IsNullOrEmpty(u.Texto))
                    {
                        <span>@u.Texto</span>
                    }
                </div>
            }
            else if (msg is MensajeAsistente a)
            {
                <div class="chat-bubble chat-bubble-ai">
                    <i class="bi bi-robot me-2 opacity-50 flex-shrink-0 mt-1"></i>
                    <span style="white-space: pre-wrap">@a.Texto</span>
                </div>
            }
            else if (msg is MensajeHerramienta h)
            {
                <div class="chat-tool-badge @(h.Ejecutando ? "chat-tool-running" : "chat-tool-done")">
                    <i class="bi @(h.Ejecutando ? "bi-gear-fill" : "bi-check-circle-fill") me-1"></i>
                    <span>@NombreLegible(h.Nombre)</span>
                    @if (h.Ejecutando)
                    {
                        <span class="spinner-border spinner-border-sm ms-1" style="width:.7rem;height:.7rem"></span>
                    }
                </div>
            }
        }

        @if (_error is not null)
        {
            <div class="alert alert-danger mx-0 my-1 py-2 px-3 small" role="alert">
                <i class="bi bi-exclamation-triangle me-1"></i>@_error
            </div>
        }
    </div>

    @if (_adjuntos.Count > 0)
    {
        <div class="chat-attachments">
            @for (var i = 0; i < _adjuntos.Count; i++)
            {
                var idx = i;
                <div class="chat-attachment-item">
                    <img src="@_adjuntos[idx].DataUrl" class="chat-attachment-img" alt="@_adjuntos[idx].Nombre" />
                    <button class="chat-attachment-remove" @onclick="() => EliminarAdjunto(idx)" title="Quitar">
                        <i class="bi bi-x"></i>
                    </button>
                </div>
            }
        </div>
    }

    <div class="chat-input-area">
        <textarea class="form-control chat-textarea"
                  @ref="_textareaRef"
                  @bind="_inputText"
                  @bind:event="oninput"
                  @onkeydown="OnKeyDown"
                  placeholder="Escribe un mensaje…"
                  rows="1"
                  disabled="@_loading"></textarea>
        <label class="btn btn-outline-secondary chat-attach-btn @(_loading ? "disabled" : "")"
               title="Adjuntar imagen">
            <i class="bi bi-paperclip"></i>
            <InputFile OnChange="OnArchivoSeleccionado" accept="image/*" multiple style="display:none" disabled="@_loading" />
        </label>
        <button class="btn btn-outline-secondary chat-mic-btn"
                @onclick="ToggleMic"
                disabled="@_loading"
                title="Dictar mensaje">
            <i class="bi @(_escuchando ? "bi-mic-fill text-danger" : "bi-mic")"></i>
        </button>
        <button class="btn btn-primary chat-send-btn"
                @onclick="SendMessage"
                disabled="@(_loading || (string.IsNullOrWhiteSpace(_inputText) && _adjuntos.Count == 0))"
                title="Enviar (Enter)">
            @if (_loading)
            {
                <span class="spinner-border spinner-border-sm"></span>
            }
            else
            {
                <i class="bi bi-send-fill"></i>
            }
        </button>
    </div>
</div>

@code {
    // ── Modelo de mensajes UI ────────────────────────────────────────────
    private abstract class Mensaje { }
    private sealed class MensajeUsuario(string texto, IReadOnlyList<string>? dataUrls = null) : Mensaje
    {
        public string Texto => texto;
        public IReadOnlyList<string>? ImagenDataUrls => dataUrls;
    }
    private sealed class MensajeAsistente(string texto) : Mensaje { public string Texto => texto; }
    private sealed class MensajeHerramienta : Mensaje
    {
        public required string Nombre { get; init; }
        public bool Ejecutando { get; set; } = true;
    }

    // ── Modelo de adjuntos ───────────────────────────────────────────────
    private record Adjunto(string Nombre, string ContentType, string DataUrl);

    // ── Estado ───────────────────────────────────────────────────────────
    private readonly List<Mensaje> _displayMessages = [];
    private readonly List<string> _apiMessages = [];  // JSON strings en formato OpenAI
    private readonly List<Adjunto> _adjuntos = [];
    private string _inputText = "";
    private bool _loading;
    private string? _error;
    private bool _shouldScroll;
    private bool _shouldFocusInput;
    private ElementReference _textareaRef;
    private bool _escuchando;
    private DotNetObjectReference<ChatPanel>? _selfRef;

    // ── Ciclo de vida ────────────────────────────────────────────────────
    protected override void OnInitialized()
        => _selfRef = DotNetObjectReference.Create(this);

    public async ValueTask DisposeAsync()
    {
        try { await JS.InvokeVoidAsync("stt.stop"); } catch { }
        _selfRef?.Dispose();
    }

    // ── Auto-scroll ──────────────────────────────────────────────────────
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScroll)
        {
            _shouldScroll = false;
            try { await JS.InvokeVoidAsync("chat.scrollToBottom", "chat-messages"); } catch { }
        }

        if (_shouldFocusInput)
        {
            _shouldFocusInput = false;
            try { await _textareaRef.FocusAsync(); } catch { }
        }
    }

    // ── Adjuntos ─────────────────────────────────────────────────────────
    private async Task OnArchivoSeleccionado(InputFileChangeEventArgs e)
    {
        const long maxBytes = 4 * 1024 * 1024; // 4 MB
        _error = null;

        foreach (var file in e.GetMultipleFiles(4))
        {
            if (!file.ContentType.StartsWith("image/"))
            {
                _error = $"{file.Name}: solo se permiten imágenes (JPG, PNG, GIF, WebP).";
                continue;
            }
            if (file.Size > maxBytes)
            {
                _error = $"{file.Name} supera el límite de 4 MB.";
                continue;
            }

            using var stream = file.OpenReadStream(maxBytes);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var base64 = Convert.ToBase64String(ms.ToArray());
            var dataUrl = $"data:{file.ContentType};base64,{base64}";
            _adjuntos.Add(new Adjunto(file.Name, file.ContentType, dataUrl));
        }

        StateHasChanged();
    }

    private void EliminarAdjunto(int i)
    {
        if (i >= 0 && i < _adjuntos.Count)
            _adjuntos.RemoveAt(i);
    }

    // ── Envío ────────────────────────────────────────────────────────────
    private async Task SendMessage()
    {
        var texto = _inputText.Trim();
        if ((string.IsNullOrEmpty(texto) && _adjuntos.Count == 0) || _loading) return;

        _inputText = "";
        _error = null;

        // Capturar adjuntos actuales y limpiar la lista antes de renderizar
        var dataUrls = _adjuntos.Select(a => a.DataUrl).ToList();
        _displayMessages.Add(new MensajeUsuario(texto, dataUrls.Count > 0 ? dataUrls : null));

        string apiMessage;
        if (_adjuntos.Count == 0)
        {
            apiMessage = $"{{\"role\":\"user\",\"content\":{JsonSerializer.Serialize(texto)}}}";
        }
        else
        {
            var content = new JsonArray();
            if (!string.IsNullOrEmpty(texto))
                content.Add(new JsonObject { ["type"] = "text", ["text"] = texto });
            foreach (var adj in _adjuntos)
                content.Add(new JsonObject
                {
                    ["type"] = "image_url",
                    ["image_url"] = new JsonObject { ["url"] = adj.DataUrl }
                });

            apiMessage = new JsonObject
            {
                ["role"] = "user",
                ["content"] = content
            }.ToJsonString();
        }

        _adjuntos.Clear();
        _apiMessages.Add(apiMessage);

        await RunLoop();
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
            await SendMessage();
    }

    // ── Loop de tool-calling ─────────────────────────────────────────────
    private async Task RunLoop()
    {
        _loading = true;
        _shouldScroll = true;
        var cerrarChat = false;
        StateHasChanged();

        try
        {
            while (true)
            {
                var json = await CallApi();
                if (json is null)
                {
                    _error = "Error al conectar con el asistente. Comprueba la API key en configuración.";
                    break;
                }

                var choice = json["choices"]?[0];
                if (choice is null) { _error = "Respuesta inesperada."; break; }

                var message = choice["message"]!;
                var finishReason = choice["finish_reason"]?.GetValue<string>() ?? "stop";

                _apiMessages.Add(message.ToJsonString());

                if (finishReason is "stop" or "end_turn")
                {
                    var content = message["content"]?.GetValue<string>() ?? "";
                    _displayMessages.Add(new MensajeAsistente(content));
                    break;
                }

                if (finishReason == "tool_calls")
                {
                    var toolCalls = message["tool_calls"]?.AsArray();
                    if (toolCalls is null) break;

                    foreach (var tc in toolCalls)
                    {
                        var name    = tc!["function"]!["name"]!.GetValue<string>();
                        var argsRaw = tc["function"]!["arguments"]!.GetValue<string>();
                        var callId  = tc["id"]!.GetValue<string>();

                        var badge = new MensajeHerramienta { Nombre = name };
                        _displayMessages.Add(badge);
                        _shouldScroll = true;
                        StateHasChanged();
                        await Task.Delay(1); // cede el hilo para que Blazor muestre el spinner

                        // Ejecutar el tool via McpToolService (handler C# de la página activa)
                        string resultado;
                        using (var doc = JsonDocument.Parse(argsRaw.Length > 0 ? argsRaw : "{}"))
                        {
                            resultado = await Mcp.ExecuteTool(name, doc.RootElement);
                        }

                        badge.Ejecutando = false;
                        _apiMessages.Add(
                            $"{{\"role\":\"tool\",\"tool_call_id\":{JsonSerializer.Serialize(callId)},\"content\":{JsonSerializer.Serialize(resultado)}}}");

                        if (Mcp.TakeCloseChat()) cerrarChat = true;
                    }

                    _shouldScroll = true;
                    StateHasChanged();
                    continue;
                }

                break; // finish_reason desconocido
            }
        }
        catch (Exception ex)
        {
            _error = $"Error inesperado: {ex.Message}";
        }
        finally
        {
            _loading = false;
            _shouldScroll = true;
            _shouldFocusInput = true;
            StateHasChanged();
        }

        if (cerrarChat && _error is null)
        {
            await Task.Delay(900);
            try { await JS.InvokeVoidAsync("chat.hide"); } catch { }
        }
    }

    // ── Llamada al BFF ───────────────────────────────────────────────────
    private async Task<JsonNode?> CallApi()
    {
        // Obtener los tools que la página activa tiene registrados ahora mismo
        var toolsJson = Mcp.GetOpenAiToolsJson();

        var messagesJson = "[" + string.Join(",", _apiMessages) + "]";

        // Incluir tools solo si hay alguno registrado
        var body = toolsJson == "[]"
            ? $"{{\"messages\":{messagesJson}}}"
            : $"{{\"messages\":{messagesJson},\"tools\":{toolsJson}}}";

        var client = HttpFactory.CreateClient("BffInternal");
        using var content = new StringContent(body, Encoding.UTF8, "application/json");
        using var response = await client.PostAsync("/bff/ai/chat", content);

        if (!response.IsSuccessStatusCode) return null;

        return await JsonNode.ParseAsync(await response.Content.ReadAsStreamAsync());
    }

    // ── Speech to text ───────────────────────────────────────────────────
    private async Task ToggleMic()
    {
        if (_escuchando)
        {
            await JS.InvokeVoidAsync("stt.stop");
            _escuchando = false;
            return;
        }
        var ok = await JS.InvokeAsync<bool>("stt.start", _selfRef);
        if (ok) _escuchando = true;
    }

    [JSInvokable]
    public void OnSpeechResult(string texto)
    {
        _inputText = texto;
        _escuchando = false;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnSpeechEnd()
    {
        _escuchando = false;
        StateHasChanged();
    }

    // ── Helper ───────────────────────────────────────────────────────────
    private static string NombreLegible(string name) => name switch
    {
        "buscar_empleados" => "Buscando empleado",
        "buscar_secciones" => "Buscando secciones",
        "crear_usuario"    => "Cubriendo datos usuario",
        "crear_empleado"   => "Cubriendo datos empleado",
        _                  => name.Replace('_', ' ')
    };
}
